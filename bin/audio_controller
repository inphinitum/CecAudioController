#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import logging
import signal

import audio_device_controller.core
import audio_device_controller.events

controller = None
session = None


def on_exit():
    if controller is not None:
        controller.cleanup()

    if session is not None:
        session.cleanup()


def main():
    # Capture terminate signals for proper cleanup.
    signal.signal(signal.SIGTERM, on_exit)

    logging.basicConfig(filename='myapp.log', level=logging.INFO)
    logging.info("Started")

    parser = argparse.ArgumentParser(description="Control an audio device via CEC.")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-power_on", action="store_false")
    group.add_argument("-standby", action="store_false")
    group.add_argument("-event_listener", action="store_false")
    arguments = parser.parse_args()

    try:
        global controller
        controller = audio_device_controller.core.AudioDeviceControllerCec()
        controller.initialize()

        if arguments.power_on:
            controller.power_on()

        elif arguments.standby:
            controller.standby()

        else:
            global session
            session = audio_device_controller.core.Session(controller)
            session.initialize()

            # Gather configuration options
            config = audio_device_controller.events.ConfigOptions()
            config.read_from_file()

            logging.info("Initialization OK, listening for events on " + config.rest_url)
            with audio_device_controller.events.EventHandler(session, config) as ev_handler:
                while True:
                    ev_handler.listen_for_events()

    except (audio_device_controller.core.CecError, audio_device_controller.events.EventError) as e:
        logging.critical(e.message)

    on_exit()

    logging.info("Exiting")

if __name__ == "__main__":
    main()
